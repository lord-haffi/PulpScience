[
  {
    "title": "Selfishness is in your DNA",
    "content": "A couple of years ago, while preparing for my prospective Bachelor thesis project, a term caught my eye that I had never read before: 'selfish DNA'. We humans are really good at ascribing human attributes to other things, aren't we? Fairy tales are the best demonstration of this. There you can find the 'bad' wolf, the 'wise' owl and the 'trusty' steed all in one place, when really the wolf is just grabbing some food, the owl is simply looking for food and the horse likely knows who provides it with its food. In a sense you could say that what they are doing is neither 'bad', nor 'wise' or 'trusty' - it is just working insofar as they keep 'being'. \n \n So how is it that we now see selfishness in something as lifeless as DNA? In the end, the principal function of DNA is to store information. It consists of four bases: Adenine, Thymine, Guanine and Cytosine or in short A, T, G and C. Concatenated in the correct order, these bases can encode useful information, such as most popularly a protein, which can fulfill some task in the cell. If we regard these proteins as commands, some would need to \"Reinforce the cell!\", others would be ordered to \"Communicate with the neighbouring cell!\" and others again would be required to \"Destroy those foreign molecules!\". Through this principle (and a lot, lot more that is going on inside the cell), you and I are kept alive, kept thinking, reading writing, eating - well, being! \n \n There are proteins (\"commands\") for nearly anything in the cell and all of them are based on the sequence of A, T, G and C in the DNA. Now, we know that DNA can mutate, which would suddenly change one base for another and we further know that DNA can be reshuffled in the course of reproduction. So what if at some point, a sequence of DNA were to read \"Copy and paste me somewhere else!\"? What if a sequence would suddenly code for a protein that is programmed to replicate its own code and insert it randomly somewhere else in the DNA? Well, hold on for a second! Now, there are two copies. Once they replicate, there will be four, then eight and before I know it, I will be swallowed by selfishness! Well, let's put it like this: there is a good reason that the vast majority of your genetic code is dubbed \"junk DNA\", since it has no apparent function for your survival. Your genetic blueprint is filled with stuffer, which seems to do nothing whatsoever. All the while, this stuffer is giving the cell more work when it duplicates, since all of that nothingness is also being duplicated. Luckily, evolution is a thing and our cells are able to develop defenses against this madness in the form of further molecular actors, which recognise and inactivate such self-replicating elements. \n \n But the defenses of your cells are not the only reason that selfish DNA is not completely taking over your genome. If these genetic parasites were to overly burden an organism with their irrelevance, then the organism would simply die out, since it would no longer be able to compete in the struggle for life. This fact is screaming 'evolution' at us. Because with the organism, the selfish DNA, itself being the reason for the extinction, would also vanish from the face of the earth. In fact, this likely happened many times and will keep on happening. However only the selfish DNA that replicates inside the genome enough to stay ahead of the cellular defenses but not too much to overburden the cell, will persevere for us to discover it. On a different notion, random insertion and shuffling of selfish DNA will itself be a driver of change and evolution in a species, since it might disrupt old and create new genetic elements. All of this demonstrates that evolution is not merely a rule that is imposed on animals and plants to keep them busy. It is the concept acting on - and producing - everything with the ability to change and to make more of itself. This starts with complex organisms, such as animals and plants, it holds true for viruses, which we would not even consider 'alive' and apparently also affects simple molecules. \n \n So is your DNA selfish? And does this moreover make you a selfish person? Why, surely not! As always, we humans are just great at imposing our way of thinking on the universe. The DNA does not think to harm anything, let alone only think of itself - it does not think at all. Just like a virus is not evil because it infects an organism and has itself be replicated - also without purposefully wanting it. At some point, both selfish DNA and viruses just emerged due to some random mutations (and a bit more going on behind the scenes) and in the way of evolution they simply worked. No, your DNA is not selfish. It just keeps 'being'.",
    "authors": [
      1
    ],
    "featuredImage": "selfish_dna.png",
    "date": "08/01/2022",
    "tags": [
      "evolution",
      "DNA",
      "viruses"
    ],
    "category": "Biology",
    "series": "",
  },
  {
    "title": "Quantum Computers aren't fast Computers",
    "content": "To understand why quantum computers aren’t just computers which run faster through some kind of „quantum magic“, we need to talk about their history and dip our toe in complexity classes. Don’t worry, it’s not that boring. \n \n Quantum mechanics is weird. In fact, it is not even really mechanics. It is a mathematical concept developed in the 1920s to explain a series of strange phenomena, which itself introduced even more strange phenomena. Quantum mechanics is so weird that one of its most prominent founders, Albert Einstein, became the most prominent critic of his own theory. The amazing thing about quantum mechanics is that - even whilst being wildly unintuitive - it has lead us to stunning theories predicting our physical world with great accuracy. That’s why it is still around. \n \n As it turns out, the weirdness of quantum mechanics can be used to our advantage. In 1982, Richard Feynman proposed that, in order to simulate quantum mechanics on a computer, the computer itself may as well make use of them. Fast forward a few years and some ridiculously smart people (David Deutsch, Lou Grover, Peter Shor and many more) figured out the first algorithms that could be run on a quantum computer and solve problems more efficiently than the best known classical counterpart. \n \n You might have noticed the usage of the word efficiently in the last paragraph. This hints at a key concept in computer science. In a nutshell, a computation is efficient if the time it takes to complete it doesn’t blow up exponentially if we scale the problem. A great example for a problem which can’t be solved efficiently by a traditional computer (or you) is the question of how to factorise an integer with prime numbers. It’s pretty intuitive for smaller numbers, say 5 x 7 = 35. How about 2 x 2 x 3 x 5 x 7 = 420? Math tells us that there is some decomposition for any integer, but we don’t know how it looks like. This problem is (believed to be) so difficult to solve, that we built a considerable chunk of internet security on it. The number of computing steps it takes a classical computer to solve scales very fast with the number of digits. In more technical terms, we don’t know about any algorithm that can find prime factors in polynomial time, and it is thus believed to be in the class NP. You can think of NP problems as taking unreasonable long to solve with a classical computer, while P problems are solvable on a human timescale. \n \n The reason why quantum computers are so exciting is that their magic ingredients allow them to execute Shor’s algorithm, which can find a prime factor decomposition in significantly less steps than a classical computer! In other words, while solving the prime factor problem is inefficient (i.e. NP) on a classical computer, it is efficient on a quantum computer (i.e. BQP, but I will not go down the rabbit hole of quantum complexity classes today). How does the quantum computer do that? \n \n Quantum computers can run special algorithms since they make use of certain quantum mechanical phenomena. For example, while a classical computer stores and manipulates information encoded as zeros and ones, a quantum computer doesn't have to decide right away. During a computation, that is before we ask the quantum computer for a result, it can store information in superposition of the two states. This means that the information is neither a zero nor a one, but both at the same time. In a nutshell, this allows the quantum computer to perform a computation on many different values simultaneously. This is called quantum parallelism and is at the core of many quantum algorithms and cannot be simulated efficiently (ah, there it is again) on a classical computer! There are even more things in the quantum information box of tricks, and together they enable all sorts of problem solving goodness. \n \n Why did I choose this title then? Well, there are two things I want to point out. First of all, current quantum computers suck. It takes a giant room, huge machinery and lots of personnel to operate them, much like in the early days of classical computers. But even if they get more powerful in the future, they will not replace the device you are reading this on. They will probably one day have a similar purpose as your GPU; serving as a co-processor for certain applications. \n \n Secondly, and more importantly: it is still just a computing device. Computers don’t solve problems, algorithms do. Yes, quantum computers are exciting, especially for natural scientists and their insane computing needs. But in order for them to be actually useful, we need to come up with algorithms that are even worth running on quantum computers. In reality, there is only a handful of them right now.",
    "authors": [
      2
    ],
    "featuredImage": "Quantum_PC.png",
    "date": "18/04/2022",
    "tags": [
      "computer science",
      "quantum computing",
      "computation"
    ],
    "category": "Physics",
    "series": "",
  },
]